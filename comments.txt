// const createNode = (puzzle, movement) => {
//   switch (movement) {
//     case 'Right':
//       return moveRight(puzzle);
//     case 'Left':
//       return moveLeft(puzzle);
//     case 'Up':
//       return moveUp(puzzle);
//     case 'Down':
//       return moveDown(puzzle);
//     default:
//       break;
//   }
// };

// const moveRight = (puzzle) => {
//   console.log('Right');
//   const [x, y] = getPosition(puzzle);
//   let row = puzzle[y];
//   [row[x], row[x + 1]] = [row[x + 1], row[x]];
//   puzzle[y] = row;
//   console.log(puzzle);
//   return puzzle;
// };

// const moveLeft = (puzzle) => {
//   console.log('Left');
//   const [x, y] = getPosition(puzzle);
//   let row = puzzle[y];
//   [row[x], row[x - 1]] = [row[x - 1], row[x]];
//   puzzle[y] = row;
//   console.log('Move', puzzle);
//   return puzzle;
// };

// const moveUp = (puzzle) => {
//   console.log('Up');
//   const [x, y] = getPosition(puzzle);
//   let [curRow, upperRow] = [puzzle[y], puzzle[y + 1]];
//   const aux = curRow[x];
//   curRow[x] = upperRow[x];
//   upperRow[x] = aux;
//   puzzle[y] = curRow;
//   puzzle[y + 1] = upperRow;
//   console.log(puzzle);
//   return puzzle;
// };

// const moveDown = (puzzle) => {
//   console.log('Down');
//   const [x, y] = getPosition(puzzle);
//   console.log(puzzle);
//   let [curRow, lowerRow] = [puzzle[y], puzzle[y - 1]];
//   const aux = curRow[x];
//   curRow[x] = lowerRow[x];
//   lowerRow[x] = aux;
//   puzzle[y] = curRow;
//   puzzle[y - 1] = lowerRow;
//   console.log(puzzle);
//   return puzzle;
// };

// PUZZLE
// const movePiece = (currentPuzzle) => {
//   const blankStartPosition = getPosition(currentPuzzle);
//   const movements = checkPossibleMovements(blankStartPosition);

//   if (!movements) {
//     console.log('movePiece Error');
//   }

//   this.createChildren(movements);
// };

// const checkPossibleMovements = (positions) => {
//   let possibleMovements;
//   switch (JSON.stringify(positions)) {
//     case JSON.stringify([0, 0]):
//       possibleMovements = TOP_LEFT;
//       break;
//     case JSON.stringify([1, 0]):
//       possibleMovements = TOP_MIDDLE;
//       break;
//     case JSON.stringify([2, 0]):
//       possibleMovements = TOP_RIGHT;
//       break;
//     case JSON.stringify([0, 1]):
//       possibleMovements = MIDDLE_LEFT;
//       break;
//     case JSON.stringify([1, 1]):
//       possibleMovements = MIDDLE;
//       break;
//     case JSON.stringify([2, 1]):
//       possibleMovements = MIDDLE_RIGHT;
//       break;
//     case JSON.stringify([0, 2]):
//       possibleMovements = BOTTOM_LEFT;
//       break;
//     case JSON.stringify([1, 2]):
//       possibleMovements = BOTTOM_MIDDLE;
//       break;
//     case JSON.stringify([2, 2]):
//       possibleMovements = BOTTOM_RIGHT;
//       break;
//     default:
//       console.log('ERROR');
//       break;
//   }

//   return possibleMovements;
// };

// const selectCurrent = (height, children) => {
//   children;
// };

// const createChildren = (movements, goal, currentPuzzle, height) => {
//   const newNodes = movements.map((movement) => {
//     return {
//       puzzle: createNode(_.cloneDeep(currentPuzzle), movement),
//       height,
//     };
//   });

//   return newNodes.map((ele) => {
//     return {
//       ...ele,
//       distance: heuristic(ele.puzzle, goal, height),
//     };
//   });
// };

// const solve = (solution, nodes) => {
//   // Check if start is equal to goal
//   if (JSON.stringify(solution.start) == JSON.stringify(solution.goal)) {
//     return true;
//   }

//   // Check initial position and movements
//   const initialPosition = getPosition(solution.current);
//   const initialMovements = checkPossibleMovements(initialPosition);
//   const children = createChildren(
//     initialMovements,
//     _.cloneDeep(solution.goal),
//     _.cloneDeep(solution.current),
//     _.cloneDeep(solution.height)
//   );

//   if (
//     children.find(
//       (child) => JSON.stringify(child.puzzle) == JSON.stringify(solution.goal)
//     )
//   ) {
//     console.log('Found a solution');
//     return true;
//   }

//   // Select current and add height
//   // TODO: create function to select the closest to the goal as the new current

//   solution.height = 1;

//   console.log('Children Created', children);

//   let found = null;
//   while (!found) {
//     // TODO: check if current is equal to solution
//     // TODO: create children based on the
//   }

//   // while (JSON.stringify(solution.start) != JSON.stringify(solution.goal)) {}
// };
